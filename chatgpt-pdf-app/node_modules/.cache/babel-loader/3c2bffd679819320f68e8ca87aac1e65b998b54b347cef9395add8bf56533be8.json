{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { renderAudio, toAudioBuffer } from './audioProcessing';\nvar WAV_HEADER_LENGTH_BYTES = 44;\nvar BYTES_PER_SAMPLE = 2;\nvar RIFF_FILE_MAX_BYTES = 4294967295;\nvar HEADER = {\n  AUDIO_FORMAT: {\n    offset: 20,\n    value: 1\n  },\n  BITS_PER_SAMPLE: {\n    offset: 34,\n    value: BYTES_PER_SAMPLE * 8\n  },\n  BLOCK_ALIGN: {\n    offset: 32\n  },\n  BYTE_RATE: {\n    offset: 28\n  },\n  CHANNEL_COUNT: {\n    offset: 22\n  },\n  CHUNK_ID: {\n    offset: 0,\n    value: 0x52494646\n  },\n  CHUNK_SIZE: {\n    offset: 4\n  },\n  FILE_FORMAT: {\n    offset: 8,\n    value: 0x57415645\n  },\n  SAMPLE_RATE: {\n    offset: 24\n  },\n  SUBCHUNK1_ID: {\n    offset: 12,\n    value: 0x666d7420\n  },\n  SUBCHUNK1_SIZE: {\n    offset: 16,\n    value: 16\n  },\n  SUBCHUNK2_ID: {\n    offset: 36,\n    value: 0x64617461\n  },\n  SUBCHUNK2_SIZE: {\n    offset: 40\n  } // actual audio data size\n};\nvar fourCharsToInt = function (chars) {\n  return chars.charCodeAt(0) << 24 | chars.charCodeAt(1) << 16 | chars.charCodeAt(2) << 8 | chars.charCodeAt(3);\n};\nvar WAV_HEADER_FLAGS = {\n  data: fourCharsToInt('data'),\n  fmt: fourCharsToInt('fmt '),\n  RIFF: fourCharsToInt('RIFF'),\n  WAVE: fourCharsToInt('WAVE')\n};\nvar writeWavHeader = function (_a) {\n  var arrayBuffer = _a.arrayBuffer,\n    channelCount = _a.channelCount,\n    sampleRate = _a.sampleRate;\n  var byteRate = sampleRate * channelCount * BYTES_PER_SAMPLE; // bytes/sec\n  var blockAlign = channelCount * BYTES_PER_SAMPLE;\n  var dataView = new DataView(arrayBuffer);\n  /*\n   * The maximum size of a RIFF file is 4294967295 bytes and since the header takes up 44 bytes there are 4294967251 bytes left for the\n   * data chunk.\n   */\n  var dataChunkSize = Math.min(dataView.byteLength - WAV_HEADER_LENGTH_BYTES, RIFF_FILE_MAX_BYTES - WAV_HEADER_LENGTH_BYTES);\n  dataView.setUint32(HEADER.CHUNK_ID.offset, HEADER.CHUNK_ID.value); // \"RIFF\"\n  dataView.setUint32(HEADER.CHUNK_SIZE.offset, arrayBuffer.byteLength - 8, true); // adjustment for the first two headers - chunk id + file size\n  dataView.setUint32(HEADER.FILE_FORMAT.offset, HEADER.FILE_FORMAT.value); // \"WAVE\"\n  dataView.setUint32(HEADER.SUBCHUNK1_ID.offset, HEADER.SUBCHUNK1_ID.value); // \"fmt \"\n  dataView.setUint32(HEADER.SUBCHUNK1_SIZE.offset, HEADER.SUBCHUNK1_SIZE.value, true);\n  dataView.setUint16(HEADER.AUDIO_FORMAT.offset, HEADER.AUDIO_FORMAT.value, true);\n  dataView.setUint16(HEADER.CHANNEL_COUNT.offset, channelCount, true);\n  dataView.setUint32(HEADER.SAMPLE_RATE.offset, sampleRate, true);\n  dataView.setUint32(HEADER.BYTE_RATE.offset, byteRate, true);\n  dataView.setUint16(HEADER.BLOCK_ALIGN.offset, blockAlign, true);\n  dataView.setUint16(HEADER.BITS_PER_SAMPLE.offset, HEADER.BITS_PER_SAMPLE.value, true);\n  dataView.setUint32(HEADER.SUBCHUNK2_ID.offset, HEADER.SUBCHUNK2_ID.value); // \"data\"\n  dataView.setUint32(HEADER.SUBCHUNK2_SIZE.offset, dataChunkSize, true);\n};\nexport var readWavHeader = function (dataView) {\n  var header = dataView.getUint32(0, false);\n  if (WAV_HEADER_FLAGS.RIFF !== header) {\n    console.error('Missing RIFF header in WAVE file');\n    return;\n  }\n  if (WAV_HEADER_FLAGS.WAVE !== dataView.getUint32(HEADER.FILE_FORMAT.offset, false)) {\n    console.error('Missing WAVE header in WAVE file');\n    return;\n  }\n  if (WAV_HEADER_FLAGS.fmt !== dataView.getUint32(HEADER.SUBCHUNK1_ID.offset, false)) {\n    console.error('Missing fmt header in WAVE file');\n    return;\n  }\n  return {\n    audioDataSizeBytes: dataView.getUint32(HEADER.SUBCHUNK2_SIZE.offset, true),\n    audioDataStartOffset: WAV_HEADER_LENGTH_BYTES,\n    channelCount: dataView.getUint16(HEADER.CHANNEL_COUNT.offset, true),\n    sampleRate: dataView.getUint32(HEADER.SAMPLE_RATE.offset, true)\n  };\n};\nvar splitDataByChannel = function (audioBuffer) {\n  return Array.from({\n    length: audioBuffer.numberOfChannels\n  }, function (_, i) {\n    return audioBuffer.getChannelData(i);\n  });\n};\n/**\n * In a WAV file, samples for each channel are usually interleaved, meaning samples from each channel are grouped together sequentially.\n * For example, in a stereo audio file (2 channels), samples alternate between the left and right channels.\n * @param arrayBuffer\n * @param dataByChannel\n */\nvar writeWavAudioData = function (_a) {\n  var arrayBuffer = _a.arrayBuffer,\n    dataByChannel = _a.dataByChannel;\n  var dataView = new DataView(arrayBuffer);\n  var channelCount = dataByChannel.length;\n  dataByChannel.forEach(function (channelData, channelIndex) {\n    var writeOffset = WAV_HEADER_LENGTH_BYTES + channelCount * channelIndex;\n    channelData.forEach(function (float32Value) {\n      dataView.setInt16(writeOffset, float32Value < 0 ? Math.max(-1, float32Value) * 32768 : Math.min(1, float32Value) * 32767, true);\n      writeOffset += channelCount * BYTES_PER_SAMPLE;\n    });\n  });\n};\nexport var encodeToWaw = function (file, sampleRate) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var audioBuffer, _a, numberOfSamples, fileSizeBytes, arrayBuffer;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _a = renderAudio;\n          return [4 /*yield*/, toAudioBuffer(file)];\n        case 1:\n          return [4 /*yield*/, _a.apply(void 0, [_b.sent(), sampleRate])];\n        case 2:\n          audioBuffer = _b.sent();\n          numberOfSamples = audioBuffer.duration * sampleRate;\n          fileSizeBytes = numberOfSamples * audioBuffer.numberOfChannels * BYTES_PER_SAMPLE + WAV_HEADER_LENGTH_BYTES;\n          arrayBuffer = new ArrayBuffer(fileSizeBytes);\n          writeWavHeader({\n            arrayBuffer: arrayBuffer,\n            channelCount: audioBuffer.numberOfChannels,\n            sampleRate: sampleRate\n          });\n          writeWavAudioData({\n            arrayBuffer: arrayBuffer,\n            dataByChannel: splitDataByChannel(audioBuffer)\n          });\n          return [2 /*return*/, new Blob([arrayBuffer], {\n            type: 'audio/wav'\n          })];\n      }\n    });\n  });\n};","map":{"version":3,"names":["__awaiter","__generator","renderAudio","toAudioBuffer","WAV_HEADER_LENGTH_BYTES","BYTES_PER_SAMPLE","RIFF_FILE_MAX_BYTES","HEADER","AUDIO_FORMAT","offset","value","BITS_PER_SAMPLE","BLOCK_ALIGN","BYTE_RATE","CHANNEL_COUNT","CHUNK_ID","CHUNK_SIZE","FILE_FORMAT","SAMPLE_RATE","SUBCHUNK1_ID","SUBCHUNK1_SIZE","SUBCHUNK2_ID","SUBCHUNK2_SIZE","fourCharsToInt","chars","charCodeAt","WAV_HEADER_FLAGS","data","fmt","RIFF","WAVE","writeWavHeader","_a","arrayBuffer","channelCount","sampleRate","byteRate","blockAlign","dataView","DataView","dataChunkSize","Math","min","byteLength","setUint32","setUint16","readWavHeader","header","getUint32","console","error","audioDataSizeBytes","audioDataStartOffset","getUint16","splitDataByChannel","audioBuffer","Array","from","length","numberOfChannels","_","i","getChannelData","writeWavAudioData","dataByChannel","forEach","channelData","channelIndex","writeOffset","float32Value","setInt16","max","encodeToWaw","file","numberOfSamples","fileSizeBytes","_b","label","apply","sent","duration","ArrayBuffer","Blob","type"],"sources":["C:/Users/Aniket/Desktop/MS/NCSU/Subjects/Infinitus/chatgpt-pdf-app/node_modules/stream-chat-react/dist/components/MediaRecorder/transcode/wav.js"],"sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport { renderAudio, toAudioBuffer } from './audioProcessing';\nvar WAV_HEADER_LENGTH_BYTES = 44;\nvar BYTES_PER_SAMPLE = 2;\nvar RIFF_FILE_MAX_BYTES = 4294967295;\nvar HEADER = {\n    AUDIO_FORMAT: { offset: 20, value: 1 },\n    BITS_PER_SAMPLE: { offset: 34, value: BYTES_PER_SAMPLE * 8 },\n    BLOCK_ALIGN: { offset: 32 },\n    BYTE_RATE: { offset: 28 },\n    CHANNEL_COUNT: { offset: 22 },\n    CHUNK_ID: { offset: 0, value: 0x52494646 },\n    CHUNK_SIZE: { offset: 4 },\n    FILE_FORMAT: { offset: 8, value: 0x57415645 },\n    SAMPLE_RATE: { offset: 24 },\n    SUBCHUNK1_ID: { offset: 12, value: 0x666d7420 },\n    SUBCHUNK1_SIZE: { offset: 16, value: 16 },\n    SUBCHUNK2_ID: { offset: 36, value: 0x64617461 },\n    SUBCHUNK2_SIZE: { offset: 40 }, // actual audio data size\n};\nvar fourCharsToInt = function (chars) {\n    return (chars.charCodeAt(0) << 24) |\n        (chars.charCodeAt(1) << 16) |\n        (chars.charCodeAt(2) << 8) |\n        chars.charCodeAt(3);\n};\nvar WAV_HEADER_FLAGS = {\n    data: fourCharsToInt('data'),\n    fmt: fourCharsToInt('fmt '),\n    RIFF: fourCharsToInt('RIFF'),\n    WAVE: fourCharsToInt('WAVE'),\n};\nvar writeWavHeader = function (_a) {\n    var arrayBuffer = _a.arrayBuffer, channelCount = _a.channelCount, sampleRate = _a.sampleRate;\n    var byteRate = sampleRate * channelCount * BYTES_PER_SAMPLE; // bytes/sec\n    var blockAlign = channelCount * BYTES_PER_SAMPLE;\n    var dataView = new DataView(arrayBuffer);\n    /*\n     * The maximum size of a RIFF file is 4294967295 bytes and since the header takes up 44 bytes there are 4294967251 bytes left for the\n     * data chunk.\n     */\n    var dataChunkSize = Math.min(dataView.byteLength - WAV_HEADER_LENGTH_BYTES, RIFF_FILE_MAX_BYTES - WAV_HEADER_LENGTH_BYTES);\n    dataView.setUint32(HEADER.CHUNK_ID.offset, HEADER.CHUNK_ID.value); // \"RIFF\"\n    dataView.setUint32(HEADER.CHUNK_SIZE.offset, arrayBuffer.byteLength - 8, true); // adjustment for the first two headers - chunk id + file size\n    dataView.setUint32(HEADER.FILE_FORMAT.offset, HEADER.FILE_FORMAT.value); // \"WAVE\"\n    dataView.setUint32(HEADER.SUBCHUNK1_ID.offset, HEADER.SUBCHUNK1_ID.value); // \"fmt \"\n    dataView.setUint32(HEADER.SUBCHUNK1_SIZE.offset, HEADER.SUBCHUNK1_SIZE.value, true);\n    dataView.setUint16(HEADER.AUDIO_FORMAT.offset, HEADER.AUDIO_FORMAT.value, true);\n    dataView.setUint16(HEADER.CHANNEL_COUNT.offset, channelCount, true);\n    dataView.setUint32(HEADER.SAMPLE_RATE.offset, sampleRate, true);\n    dataView.setUint32(HEADER.BYTE_RATE.offset, byteRate, true);\n    dataView.setUint16(HEADER.BLOCK_ALIGN.offset, blockAlign, true);\n    dataView.setUint16(HEADER.BITS_PER_SAMPLE.offset, HEADER.BITS_PER_SAMPLE.value, true);\n    dataView.setUint32(HEADER.SUBCHUNK2_ID.offset, HEADER.SUBCHUNK2_ID.value); // \"data\"\n    dataView.setUint32(HEADER.SUBCHUNK2_SIZE.offset, dataChunkSize, true);\n};\nexport var readWavHeader = function (dataView) {\n    var header = dataView.getUint32(0, false);\n    if (WAV_HEADER_FLAGS.RIFF !== header) {\n        console.error('Missing RIFF header in WAVE file');\n        return;\n    }\n    if (WAV_HEADER_FLAGS.WAVE !== dataView.getUint32(HEADER.FILE_FORMAT.offset, false)) {\n        console.error('Missing WAVE header in WAVE file');\n        return;\n    }\n    if (WAV_HEADER_FLAGS.fmt !== dataView.getUint32(HEADER.SUBCHUNK1_ID.offset, false)) {\n        console.error('Missing fmt header in WAVE file');\n        return;\n    }\n    return {\n        audioDataSizeBytes: dataView.getUint32(HEADER.SUBCHUNK2_SIZE.offset, true),\n        audioDataStartOffset: WAV_HEADER_LENGTH_BYTES,\n        channelCount: dataView.getUint16(HEADER.CHANNEL_COUNT.offset, true),\n        sampleRate: dataView.getUint32(HEADER.SAMPLE_RATE.offset, true),\n    };\n};\nvar splitDataByChannel = function (audioBuffer) {\n    return Array.from({ length: audioBuffer.numberOfChannels }, function (_, i) { return audioBuffer.getChannelData(i); });\n};\n/**\n * In a WAV file, samples for each channel are usually interleaved, meaning samples from each channel are grouped together sequentially.\n * For example, in a stereo audio file (2 channels), samples alternate between the left and right channels.\n * @param arrayBuffer\n * @param dataByChannel\n */\nvar writeWavAudioData = function (_a) {\n    var arrayBuffer = _a.arrayBuffer, dataByChannel = _a.dataByChannel;\n    var dataView = new DataView(arrayBuffer);\n    var channelCount = dataByChannel.length;\n    dataByChannel.forEach(function (channelData, channelIndex) {\n        var writeOffset = WAV_HEADER_LENGTH_BYTES + channelCount * channelIndex;\n        channelData.forEach(function (float32Value) {\n            dataView.setInt16(writeOffset, float32Value < 0 ? Math.max(-1, float32Value) * 32768 : Math.min(1, float32Value) * 32767, true);\n            writeOffset += channelCount * BYTES_PER_SAMPLE;\n        });\n    });\n};\nexport var encodeToWaw = function (file, sampleRate) { return __awaiter(void 0, void 0, void 0, function () {\n    var audioBuffer, _a, numberOfSamples, fileSizeBytes, arrayBuffer;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                _a = renderAudio;\n                return [4 /*yield*/, toAudioBuffer(file)];\n            case 1: return [4 /*yield*/, _a.apply(void 0, [_b.sent(), sampleRate])];\n            case 2:\n                audioBuffer = _b.sent();\n                numberOfSamples = audioBuffer.duration * sampleRate;\n                fileSizeBytes = numberOfSamples * audioBuffer.numberOfChannels * BYTES_PER_SAMPLE + WAV_HEADER_LENGTH_BYTES;\n                arrayBuffer = new ArrayBuffer(fileSizeBytes);\n                writeWavHeader({ arrayBuffer: arrayBuffer, channelCount: audioBuffer.numberOfChannels, sampleRate: sampleRate });\n                writeWavAudioData({ arrayBuffer: arrayBuffer, dataByChannel: splitDataByChannel(audioBuffer) });\n                return [2 /*return*/, new Blob([arrayBuffer], { type: 'audio/wav' })];\n        }\n    });\n}); };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}