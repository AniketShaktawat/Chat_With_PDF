{"ast":null,"code":"import { divMod } from './utils';\nexport var resampleWaveformData = function (waveformData, amplitudesCount) {\n  return waveformData.length === amplitudesCount ? waveformData : waveformData.length > amplitudesCount ? downSample(waveformData, amplitudesCount) : upSample(waveformData, amplitudesCount);\n};\n/**\n * The downSample function uses the Largest-Triangle-Three-Buckets (LTTB) algorithm.\n * See the thesis Downsampling Time Series for Visual Representation by Sveinn Steinarsson for more (https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf)\n * @param data\n * @param targetOutputSize\n */\nexport function downSample(data, targetOutputSize) {\n  if (data.length <= targetOutputSize || targetOutputSize === 0) {\n    return data;\n  }\n  if (targetOutputSize === 1) return [mean(data)];\n  var result = [];\n  // bucket size adjusted due to the fact that the first and the last item in the original data array is kept in target output\n  var bucketSize = (data.length - 2) / (targetOutputSize - 2);\n  var lastSelectedPointIndex = 0;\n  result.push(data[lastSelectedPointIndex]); // Always add the first point\n  var maxAreaPoint, maxArea, triangleArea;\n  for (var bucketIndex = 1; bucketIndex < targetOutputSize - 1; bucketIndex++) {\n    var previousBucketRefPoint = data[lastSelectedPointIndex];\n    var nextBucketMean = getNextBucketMean(data, bucketIndex, bucketSize);\n    var currentBucketStartIndex = Math.floor((bucketIndex - 1) * bucketSize) + 1;\n    var nextBucketStartIndex = Math.floor(bucketIndex * bucketSize) + 1;\n    var countUnitsBetweenAtoC = 1 + nextBucketStartIndex - currentBucketStartIndex;\n    maxArea = triangleArea = -1;\n    for (var currentPointIndex = currentBucketStartIndex; currentPointIndex < nextBucketStartIndex; currentPointIndex++) {\n      var countUnitsBetweenAtoB = Math.abs(currentPointIndex - currentBucketStartIndex) + 1;\n      var countUnitsBetweenBtoC = countUnitsBetweenAtoC - countUnitsBetweenAtoB;\n      var currentPointValue = data[currentPointIndex];\n      triangleArea = triangleAreaHeron(triangleBase(Math.abs(previousBucketRefPoint - currentPointValue), countUnitsBetweenAtoB), triangleBase(Math.abs(currentPointValue - nextBucketMean), countUnitsBetweenBtoC), triangleBase(Math.abs(previousBucketRefPoint - nextBucketMean), countUnitsBetweenAtoC));\n      if (triangleArea > maxArea) {\n        maxArea = triangleArea;\n        maxAreaPoint = data[currentPointIndex];\n        lastSelectedPointIndex = currentPointIndex;\n      }\n    }\n    if (typeof maxAreaPoint !== 'undefined') result.push(maxAreaPoint);\n  }\n  result.push(data[data.length - 1]); // Always add the last point\n  return result;\n}\nvar triangleAreaHeron = function (a, b, c) {\n  var s = (a + b + c) / 2;\n  return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n};\nvar triangleBase = function (a, b) {\n  return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n};\nvar mean = function (values) {\n  return values.reduce(function (acc, value) {\n    return acc + value;\n  }, 0) / values.length;\n};\nvar getNextBucketMean = function (data, currentBucketIndex, bucketSize) {\n  var nextBucketStartIndex = Math.floor(currentBucketIndex * bucketSize) + 1;\n  var nextNextBucketStartIndex = Math.floor((currentBucketIndex + 1) * bucketSize) + 1;\n  nextNextBucketStartIndex = nextNextBucketStartIndex < data.length ? nextNextBucketStartIndex : data.length;\n  return mean(data.slice(nextBucketStartIndex, nextNextBucketStartIndex));\n};\nexport var upSample = function (values, targetSize) {\n  if (!values.length) {\n    console.warn('Cannot extend empty array of amplitudes.');\n    return values;\n  }\n  if (values.length > targetSize) {\n    console.warn('Requested to extend the waveformData that is longer than the target list size');\n    return values;\n  }\n  if (targetSize === values.length) return values;\n  // eslint-disable-next-line prefer-const\n  var _a = divMod(targetSize, values.length),\n    bucketSize = _a[0],\n    remainder = _a[1];\n  var result = [];\n  for (var i = 0; i < values.length; i++) {\n    var extra = remainder && remainder-- ? 1 : 0;\n    result.push.apply(result, Array(bucketSize + extra).fill(values[i]));\n  }\n  return result;\n};","map":{"version":3,"names":["divMod","resampleWaveformData","waveformData","amplitudesCount","length","downSample","upSample","data","targetOutputSize","mean","result","bucketSize","lastSelectedPointIndex","push","maxAreaPoint","maxArea","triangleArea","bucketIndex","previousBucketRefPoint","nextBucketMean","getNextBucketMean","currentBucketStartIndex","Math","floor","nextBucketStartIndex","countUnitsBetweenAtoC","currentPointIndex","countUnitsBetweenAtoB","abs","countUnitsBetweenBtoC","currentPointValue","triangleAreaHeron","triangleBase","a","b","c","s","sqrt","pow","values","reduce","acc","value","currentBucketIndex","nextNextBucketStartIndex","slice","targetSize","console","warn","_a","remainder","i","extra","apply","Array","fill"],"sources":["C:/Users/Aniket/Desktop/MS/NCSU/Subjects/Infinitus/chatgpt-pdf-app/node_modules/stream-chat-react/dist/components/Attachment/audioSampling.js"],"sourcesContent":["import { divMod } from './utils';\nexport var resampleWaveformData = function (waveformData, amplitudesCount) {\n    return waveformData.length === amplitudesCount\n        ? waveformData\n        : waveformData.length > amplitudesCount\n            ? downSample(waveformData, amplitudesCount)\n            : upSample(waveformData, amplitudesCount);\n};\n/**\n * The downSample function uses the Largest-Triangle-Three-Buckets (LTTB) algorithm.\n * See the thesis Downsampling Time Series for Visual Representation by Sveinn Steinarsson for more (https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf)\n * @param data\n * @param targetOutputSize\n */\nexport function downSample(data, targetOutputSize) {\n    if (data.length <= targetOutputSize || targetOutputSize === 0) {\n        return data;\n    }\n    if (targetOutputSize === 1)\n        return [mean(data)];\n    var result = [];\n    // bucket size adjusted due to the fact that the first and the last item in the original data array is kept in target output\n    var bucketSize = (data.length - 2) / (targetOutputSize - 2);\n    var lastSelectedPointIndex = 0;\n    result.push(data[lastSelectedPointIndex]); // Always add the first point\n    var maxAreaPoint, maxArea, triangleArea;\n    for (var bucketIndex = 1; bucketIndex < targetOutputSize - 1; bucketIndex++) {\n        var previousBucketRefPoint = data[lastSelectedPointIndex];\n        var nextBucketMean = getNextBucketMean(data, bucketIndex, bucketSize);\n        var currentBucketStartIndex = Math.floor((bucketIndex - 1) * bucketSize) + 1;\n        var nextBucketStartIndex = Math.floor(bucketIndex * bucketSize) + 1;\n        var countUnitsBetweenAtoC = 1 + nextBucketStartIndex - currentBucketStartIndex;\n        maxArea = triangleArea = -1;\n        for (var currentPointIndex = currentBucketStartIndex; currentPointIndex < nextBucketStartIndex; currentPointIndex++) {\n            var countUnitsBetweenAtoB = Math.abs(currentPointIndex - currentBucketStartIndex) + 1;\n            var countUnitsBetweenBtoC = countUnitsBetweenAtoC - countUnitsBetweenAtoB;\n            var currentPointValue = data[currentPointIndex];\n            triangleArea = triangleAreaHeron(triangleBase(Math.abs(previousBucketRefPoint - currentPointValue), countUnitsBetweenAtoB), triangleBase(Math.abs(currentPointValue - nextBucketMean), countUnitsBetweenBtoC), triangleBase(Math.abs(previousBucketRefPoint - nextBucketMean), countUnitsBetweenAtoC));\n            if (triangleArea > maxArea) {\n                maxArea = triangleArea;\n                maxAreaPoint = data[currentPointIndex];\n                lastSelectedPointIndex = currentPointIndex;\n            }\n        }\n        if (typeof maxAreaPoint !== 'undefined')\n            result.push(maxAreaPoint);\n    }\n    result.push(data[data.length - 1]); // Always add the last point\n    return result;\n}\nvar triangleAreaHeron = function (a, b, c) {\n    var s = (a + b + c) / 2;\n    return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n};\nvar triangleBase = function (a, b) { return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2)); };\nvar mean = function (values) { return values.reduce(function (acc, value) { return acc + value; }, 0) / values.length; };\nvar getNextBucketMean = function (data, currentBucketIndex, bucketSize) {\n    var nextBucketStartIndex = Math.floor(currentBucketIndex * bucketSize) + 1;\n    var nextNextBucketStartIndex = Math.floor((currentBucketIndex + 1) * bucketSize) + 1;\n    nextNextBucketStartIndex =\n        nextNextBucketStartIndex < data.length ? nextNextBucketStartIndex : data.length;\n    return mean(data.slice(nextBucketStartIndex, nextNextBucketStartIndex));\n};\nexport var upSample = function (values, targetSize) {\n    if (!values.length) {\n        console.warn('Cannot extend empty array of amplitudes.');\n        return values;\n    }\n    if (values.length > targetSize) {\n        console.warn('Requested to extend the waveformData that is longer than the target list size');\n        return values;\n    }\n    if (targetSize === values.length)\n        return values;\n    // eslint-disable-next-line prefer-const\n    var _a = divMod(targetSize, values.length), bucketSize = _a[0], remainder = _a[1];\n    var result = [];\n    for (var i = 0; i < values.length; i++) {\n        var extra = remainder && remainder-- ? 1 : 0;\n        result.push.apply(result, Array(bucketSize + extra).fill(values[i]));\n    }\n    return result;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}